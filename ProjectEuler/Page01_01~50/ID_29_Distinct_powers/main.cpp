//Distinct powers
//Problem 29
//Consider all integer combinations of ab for 2 ¡Ü a ¡Ü 5 and 2 ¡Ü b ¡Ü 5:
//
//22 = 4, 23 = 8, 24 = 16, 25 = 32
//32 = 9, 33 = 27, 34 = 81, 35 = 243
//42 = 16, 43 = 64, 44 = 256, 45 = 1024
//52 = 25, 53 = 125, 54 = 625, 55 = 3125
//If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms :
//
//4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
//
//How many distinct terms are in the sequence generated by ab for 2 ¡Ü a ¡Ü 100 and 2 ¡Ü b ¡Ü 100 ?


//Answer:
//9183
//Completed on Sat, 20 May 2017, 12 : 10

#include <iostream>
#include <vector>
#include <set>
#include <map>
using namespace std;

#define A_LIMIT	100
#define B_LIMIT	100

void getSpecialNum(vector<int> &vec, map<int, int> &bandp, int a, int b)
{

	set<int> tempS;
	bandp.clear();
	int tempA = sqrt(a);

	for (int i = tempA; i > 1; --i)
	{
		int temp;
		for (int j = 2; j < b; ++j)
		{
			temp = pow(i, j);
			if (temp <= a)
			{
				tempS.insert(temp);
				bandp[temp] = i * b + j;
			}
			else break;
		}
	}

	vec.clear();
	set<int>::iterator ite;
	for (ite = tempS.begin(); ite != tempS.end(); ++ite)
		vec.push_back(*ite);
}

void showVec(const vector<int> &vec, map<int, int> &bandp, int a, int b)
{
	for (size_t i = 0; i < vec.size(); ++i)
		printf("%d\t%d\t%d\n", vec[i], bandp[vec[i]] / b, bandp[vec[i]] % b);

	printf("\n");
}

int main(int argc, char * argv[])
{
	vector<int> specialNum;
	map<int, int> bandp;
	getSpecialNum(specialNum, bandp, A_LIMIT, B_LIMIT);
	showVec(specialNum, bandp, A_LIMIT, B_LIMIT);
	map<int, set<int> > baseMap;


	vector<int>::iterator speciIte = specialNum.begin();
	int sum = 0;

	for (int i = 2; i <= A_LIMIT; ++i)
	{
		sum += B_LIMIT - 1;
		if (specialNum.end() == speciIte) continue;
		if (i != *speciIte) continue;
		int bp = bandp[*speciIte];
		int numBase = bp / B_LIMIT;
		int numPower = bp % B_LIMIT;
		set<int> & setRef = baseMap[numBase];
		++speciIte;
		for (int n = 2; n <= B_LIMIT; ++n)
		{
			int p = n * numPower;

			if (p <= B_LIMIT || setRef.find(p) != setRef.end())
				--sum;
			else
				setRef.insert(p);
		}
	}

	printf("a:%d\tb:%d\t%d\n", A_LIMIT, B_LIMIT, sum);

	system("pause");
	return 0;
}