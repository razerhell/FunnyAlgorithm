
先把我们假设是对的算法称作算法A，那么假设有一种算法B进行的拆分比A拆出来的和更小。
由于算法A是从最大的数开始尽可能地使用除2，那么可以预测，算法B肯定是有某一步我们除2的地方进行了相加拆分。
在这一步之前的操作均和算法A相等。这一步可以是第一步。
也就是说，在这一步之前，算法B和算法A已有的累计总和是相等的。
那么算法B从这一步的累计总和肯定是不相等的。
假设这一步要处理的数字是k，现有的累计总和是m，
则这一步之后，算法A的累计总和是m+k/2，
算法B的累计总和是m+a+b，其中a+b=k
且a,b均不等于k/2,假设a>k/2,b<k/2。
接下来算法A继续拆分k/2
算法B继续拆分a，b,
假设a > k/2
则有 
算法A     n, ...., k, k/2,......
算法B     n, ...., k, a,  .....       b
假设B在接下来的拆分中采取和算法A一样的策略，则始终无法超越A
若B在接下来的拆分中将某个数字拆分为了
c + b, 

1,
算法A     n, ...., k, k/2,.....,       k/l, 
算法B     n, ...., k, a,  .....,       b,     c 
该情况中 a,.....b,c之和必然大于k > k/2.....,k/l之和

2,
算法A     n, ...., k, k/2,.....,       k/l, 
算法B     n, ...., k, a,  .....,       c,     b
该情况中 a,.....c,b之和必然大于k/2.....,k/l之和

即有在k及其之前的序列中
算法A=算法B
在对k拆分时算法B>算法A
在之后的拆分中算法B>算法A

所以，没有比算法A更优的存在